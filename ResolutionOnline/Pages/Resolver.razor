@page "/resolver"
@using ResolutionOnline.Data
@using Resolution
@using System.Text.RegularExpressions
@inject NavigationManager NavigationManager
@inject ResolutionFlowContainer ResolutionFlowContainer
@using BlazorAnimate
@inject Clipboard.IClipboardService ClipboardService

@using static Resolution.ClausalForm;

<h3>Resolver</h3>

@if (_resolutionFlow != null)
{
    <div style="margin: auto; width:100%; text-align:center;">
        @if (_choicePrompt)
        {
            if (_literals1 != null && _literals2 != null)
            {
                ResolveEndWithAtoms();
            }

            <div class="overlay" >
                <div class="selector">
                @if (_selection != null )
                    {
                        <div style="padding: 10px">
                            <div>
                                <di style="text-align: left">
                                    These clauses clash on multiple literals
                                </di>
                                <di style="text-align: right">
                                    <button class="proofButton" @onclick="(e => _choicePrompt = !_choicePrompt)">✖</button>
                                </di>
                            </div>
                            Select the two literals to resolve on
                            <vertic>
                                @foreach (var literal in _resolutionFlow.proof.GetClause(_selection.Item1).Literals)
                                {
                                    <fol @onclick="e => SetFirstAtom(literal)"
                                         style="@($"outline: {(_literals1.Contains(literal) ? "2px dashed orange" : "1px solid gray")}")">
                                        @((MarkupString)literal.Print())
                                    </fol>
                                }
                            </vertic>
                            <vertic>
                                @foreach (var literal in _resolutionFlow.proof.GetClause(_selection.Item2).Literals)
                                {

                                    <fol @onclick="e => SetSecondAtom(literal)"
                                         style="@($"outline: {(_literals2.Contains(literal) ? "2px dashed orange" : "1px solid gray")}")">
                                        @((MarkupString)literal.Print())
                                    </fol>
                                }
                            </vertic>
                        </div>
                    }
                </div>
            </div>
        }
        @if (_renamePrompt)
        {
            <ResolutionOnline.Components.RenameVariablePrompt variablesInClause=@(_proofTools.ClauseVariables(_resolutionFlow.proof.GetClause((int)_renameOriginal))) CancelRenaming="RenameStop" RenameEnd="e => RenameEnd(e.Source, e.Target)"/>
        }
        <table style="margin: auto; text-align:left;">
            <tbody>
            @for (int index = 0; index < _resolutionFlow.proof.Applications.Count; index++)
            {
                var i = 1 + index;
                <tr>
                    <td style="color: black">
                        <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                            <math>
                                @((MarkupString)$"<i>C<sub>{i}</sub> =")
                            </math>
                        </Animate>
                    </td>
                    <td>
                        <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                            <clause draggable="true"
                                    ondragover="event.preventDefault();"
                                    style="@($"outline: {(_resolveTarget == i && _resolveTarget != _resolveSource ? "2px dashed orange" : _proofTools.IsEmptyClause(_resolutionFlow.proof.GetClause(i)) ? "1px solid white; background-color: green; color: white" : "1px solid gray")}")"
                                    @ondragenter="e => SetResolveTarget(i)"
                                    @ondragstart="e => SetResolveSource(i)"
                                    @ondrop="e => ResolveEnd()">
                                <div style="text-align: center;">
                                    @((MarkupString)_resolutionFlow.proof.GetClause(i).Print())
                                </div>
                            </clause>
                        </Animate>
                    </td>
                    <td style="text-align: left; color: black">
                        <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                            @((MarkupString)("<i>, " + _resolutionFlow.proof.Applications[i - 1].PrintMethod()))
                        </Animate>
                    </td>
                    @if (_proofTools.ClauseVariables(_resolutionFlow.proof.GetClause(i)).Count > 0)
                    {
                        <td style="width=38px">
                            <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                                <button class="proofButton" @onclick="(e => RenameStart(i))">📝</button>
                            </Animate>
                        </td>
                    }
                    else
                    {
                        <td style="width=38px">
                        </td>
                    }
                    @if (!_resolutionFlow.proof.MustKeepApplication(i))
                    {
                        <td style="width=38px">
                            <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                                <button class="proofButton" @onclick="(e => Delete(i))">✖</button>
                            </Animate>
                        </td>
                    }
                    else
                    {
                        <td style="width=38px">
                        </td>
                    }
                    <td style="text-align: left; color: black">
                        <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                            @((MarkupString)(_resolutionFlow.proof.Applications[i - 1].PrintSubstitutions()))
                        </Animate>
                    </td>
                </tr>
            }
            </tbody>
        </table>

        @* If the proof contians the empty clause, it is considered finished and the proof can be copied to the clipboard. *@
        @if (_resolutionFlow.proof.Applications.Any(x => _proofTools.IsEmptyClause(x.GetClause())))
        {
            <button @onclick="e => CopyProof()">Copy verifiable proof to clipboard</button>
        }

        <div style="height: 30px; padding-bottom : 50px;">
            @for (int ei = 0; ei < _errors.Count; ei++)
            {
                var m = ((MarkupString)_errors[ei].message);
                <vertic>
                    <Animate Animation="Animations.Fade" Duration="TimeSpan.FromSeconds(0.5)">
                        <message>
                            @m
                        </message>
                    </Animate>
                    @{
                        if (_toDeleteErrors <= ei)
                        {
                            DeleteError();
                        }
                    }
                </vertic>
            }
        </div>
    </div>
}
else
{
    <vertic>
        Please enter a formula at the start screen
    </vertic>
}




@code {
    ResolutionFlow? _resolutionFlow;
    readonly ProofTools _proofTools = new(true);

    protected override void OnInitialized()
    {
        // Update the state 
        ResolutionFlowContainer.OnStateChange += StateHasChanged;
        _resolutionFlow = ResolutionFlowContainer.Value;
    }


    /// <summary>
    /// 1st clause that is being resolved on.
    /// </summary>
    int? _resolveSource; 
    /// <summary>
    /// 2nd clause that is being resolved on.
    /// </summary>
    int? _resolveTarget; 

    HashSet<Literal> _literals1 = new HashSet<Literal>() { };
    HashSet<Literal> _literals2 = new HashSet<Literal>() { };

    /// <summary>
    /// The two clauses that are selected for resolution.
    /// </summary>
    Tuple<int, int>? _selection;

    List<ProofTools.ResolveError> _errors = new();

    /// <summary>
    /// Indicates how many error messages are currently displayed
    /// </summary>
    int _toDeleteErrors; 
    /// <summary>
    /// Indicates whether the choice prompt window should be shown.
    /// </summary>
    bool _choicePrompt; 

    /// <summary>
    /// Indicates whether the rename prompt window should be shown
    /// </summary>
    bool _renamePrompt; 
    /// <summary>
    /// 
    /// </summary>
    int? _renameOriginal;

    private void ResolveEnd()
    {
        Console.WriteLine($"ResolveEnd with {_resolveTarget} {_resolveSource}");
        if (_resolveSource == null || _resolveTarget == null)
        {
            Console.WriteLine($"Error {_resolveSource}");
            return;
        }
        if (_resolveSource != _resolveTarget)
        {
            var result = _proofTools.Resolve(
                (int) _resolveSource,
                (int) _resolveTarget,
                _resolutionFlow?.proof.GetClause((int)_resolveSource),
                _resolutionFlow?.proof.GetClause((int)_resolveTarget));
            if (result.IsLeft)
            {
                _resolutionFlow?.proof.Applications.Add(result.AsLeft);
            }
            if (result.IsMiddle)
            {
                _choicePrompt = true;
                _selection = new Tuple<int, int>((int)_resolveSource, (int)_resolveTarget);
                StateHasChanged();
                return;
            }
            if (result.IsRight)
            {
                _errors.Add(result.AsRight);

                Console.WriteLine($"Error list length: {_errors.Count} Index of new error {_errors.IndexOf(result.AsRight)} ");
            }
        }
        _resolveSource = null;
        _resolveTarget = null;
        StateHasChanged();
    }

    private void ResolveEndWithAtoms()
    {
        Console.WriteLine($"ResolveEnd with {_resolveTarget} {_resolveSource} and {_proofTools.Print(_literals1)} {_proofTools.Print(_literals2)}");
        var result = _proofTools.Resolve(
            (int)_resolveSource,
            (int)_resolveTarget,
            _resolutionFlow?.proof.GetClause((int)_resolveSource),
            _resolutionFlow?.proof.GetClause((int)_resolveTarget),
            _literals1,
            _literals2);
        if (result.IsSuccesful)
        {
            _resolutionFlow?.proof.Applications.Add(result.Resolve);
        }
        else 
        {
            _errors.Add(result.Error);
            Console.WriteLine($"Error list length: {_errors.Count} Index of new error {_errors.IndexOf(result.Error)} ");
        }

        // Reset the proof step values to their original state, where nothing has been chosen yet.
        _resolveSource = null;
        _resolveTarget = null;
        _literals1 = new HashSet<Literal> {};
        _literals2 = new HashSet<Literal> {};
        _choicePrompt = false;
        StateHasChanged();

    }

    private async void DeleteError()
    {
        _toDeleteErrors++;
        StateHasChanged();
        await Task.Delay(3000);
        _toDeleteErrors--;
        _errors.RemoveAt(0);
        StateHasChanged();
    }

    private void SetResolveSource(int index) { _resolveSource = index; StateHasChanged(); }

    private void SetResolveTarget(int index)
    {
        if (_resolveSource == null) return;
        _resolveTarget = index; 
        StateHasChanged();
    } 

    private void ResetResolve() { _resolveSource = null; StateHasChanged(); _resolveTarget = null; StateHasChanged(); }

    private void SetFirstAtom(Literal literal) { _literals1.Add(literal); StateHasChanged(); }

    private void SetSecondAtom(Literal literal) { _literals2.Add(literal); StateHasChanged(); }

    private void Delete(int index) { _resolutionFlow.proof.DeleteApplication(index); StateHasChanged(); }

    /// <summary>
    /// Invoked to finish a renaming step. Calculates the new clause where the varaible is renamed to the target name. 
    /// Adds the renaming step to the proof.
    /// </summary>
    /// <param name="source"></param>
    /// <param name="target"></param>
    private void RenameEnd(string source, string target)
    {
        var clauseUsedForRenaming = _resolutionFlow.proof.GetClause((int)_renameOriginal);
        var rename = _proofTools.RenameVariable(source, target, (int)_renameOriginal, clauseUsedForRenaming);
        _resolutionFlow.proof.Applications.Add(rename);

        RenameStop();
    }

    /// <summary>
    /// Starts the process of renaming a variable. Opens the prompt.
    /// </summary>
    /// <param name="i"></param>
    private void RenameStart(int i)
    {
        _renameOriginal = i;
        _renamePrompt = true;
        StateHasChanged();
    }

    /// <summary>
    /// Cancel the renaming process of a variable. Close the prompt.
    /// </summary>
    private void RenameStop()
    {
        _renameOriginal = null;
        _renamePrompt = false;
        StateHasChanged();
    }

    /// <summary>
    /// DISABLED Summons the Isabelle proof generator to generate the formally verifiable proof, then copies to the clipboard.
    /// </summary>
    private void CopyProof()
    {
        // var c = new Isabelle.AST.ProofConnector(Isabelle.Compiler.compileProof(_resolutionFlow.proof));
        // ClipboardService.CopyToClipboard(Isabelle.Generator.generateSingle(c.x.Item1, c.x.Item2));
    }

}

