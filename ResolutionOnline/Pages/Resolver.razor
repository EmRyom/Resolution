@page "/resolver"
@using ResolutionOnline.Data
@using Resolution
@using System.Text.RegularExpressions
@inject NavigationManager NavigationManager
@inject ResolutionFlowContainer ResolutionFlowContainer
@using BlazorAnimate
@inject Clipboard.IClipboardService ClipboardService
@using ResolutionOnline.Components;
@using static Resolution.ClausalForm;

<h3>Resolver</h3>

@if (_resolutionFlow != null)
{
    <div style="margin: auto; width:100%; text-align:center;">
        @if (_choicePrompt)
        {
            <LiteralSelector LeftLiterals=@_resolutionFlow.proof.GetClause(_resolveSource).Literals RightLiterals=@_resolutionFlow.proof.GetClause(_resolveTarget).Literals  CancelResolution="ResetResolve" Resolve="ResolveEnd"/>
        }
        @if (_renamePrompt)
        {
            <RenameVariablePrompt variablesInClause=@(_proofTools.ClauseVariables(_resolutionFlow.proof.GetClause((int)_renameOriginal))) CancelRenaming="RenameStop" Rename="e => RenameEnd(e.Source, e.Target)"/>
        }
        <table style="margin: auto; text-align:left;">
            <tbody>
            @for (int index = 0; index < _resolutionFlow.proof.Applications.Count; index++)
            {
                var i = 1 + index;
                <tr>
                    <td style="color: black">
                        <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                            <math>
                                @((MarkupString)$"<i>C<sub>{i}</sub> =")
                            </math>
                        </Animate>
                    </td>
                    <td>
                        <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                            <clause draggable="true"
                                    ondragover="event.preventDefault();"
                                    style="@($"outline: {(_resolveTarget == i && _resolveTarget != _resolveSource ? "2px dashed orange" : _proofTools.IsEmptyClause(_resolutionFlow.proof.GetClause(i)) ? "1px solid white; background-color: green; color: white" : "1px solid gray")}")"
                                    @ondragenter="e => SetResolveTarget(i)"
                                    @ondragstart="e => SetResolveSource(i)"
                                    @ondrop="e => StartLiteralSelector()">
                                <div style="text-align: center;">
                                    @((MarkupString)_resolutionFlow.proof.GetClause(i).Print())
                                </div>
                            </clause>
                        </Animate>
                    </td>
                    <td style="text-align: left; color: black">
                        <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                            @((MarkupString)("<i>, " + _resolutionFlow.proof.Applications[i - 1].PrintMethod()))
                        </Animate>
                    </td>
                    @if (_proofTools.ClauseVariables(_resolutionFlow.proof.GetClause(i)).Count > 0)
                    {
                        <td style="width=38px">
                            <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                                <button class="proofButton" @onclick="(e => RenameStart(i))">📝</button>
                            </Animate>
                        </td>
                    }
                    else
                    {
                        <td style="width=38px">
                        </td>
                    }
                    @if (!_resolutionFlow.proof.MustKeepApplication(i))
                    {
                        <td style="width=38px">
                            <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                                <button class="proofButton" @onclick="(e => Delete(i))">✖</button>
                            </Animate>
                        </td>
                    }
                    else
                    {
                        <td style="width=38px">
                        </td>
                    }
                    <td style="text-align: left; color: black">
                        <Animate Animation="Animations.ZoomIn" Duration="TimeSpan.FromSeconds(0.5)">
                            @((MarkupString)(_resolutionFlow.proof.Applications[i - 1].PrintSubstitutions()))
                        </Animate>
                    </td>
                </tr>
            }
            </tbody>
        </table>

        @* If the proof contians the empty clause, it is considered finished and the proof can be copied to the clipboard. *@
        @if (_resolutionFlow.proof.Applications.Any(x => _proofTools.IsEmptyClause(x.GetClause())))
        {
            <button @onclick="e => CopyProof()">Copy verifiable proof to clipboard</button>
        }

        <div style="height: 30px; padding-bottom : 50px;">
            @for (int ei = 0; ei < _errors.Count; ei++)
            {
                var m = ((MarkupString)_errors[ei].message);
                <vertic>
                    <Animate Animation="Animations.Fade" Duration="TimeSpan.FromSeconds(0.5)">
                        <message>
                            @m
                        </message>
                    </Animate>
                    @{
                        if (_toDeleteErrors <= ei)
                        {
                            DeleteError();
                        }
                    }
                </vertic>
            }
        </div>
    </div>
}
else
{
    <vertic>
        Please enter a formula at the start screen
    </vertic>
}




@code {
    ResolutionFlow? _resolutionFlow;
    readonly ProofTools _proofTools = new(true);

    protected override void OnInitialized()
    {
        // Update the state 
        ResolutionFlowContainer.OnStateChange += StateHasChanged;
        _resolutionFlow = ResolutionFlowContainer.Value;
    }

    /// <summary>
    /// 1st clause that is being resolved on.
    /// </summary>
    int _resolveSource = 0;

    /// <summary>
    /// 2nd clause that is being resolved on.
    /// </summary>
    int _resolveTarget = 0; 

    /// <summary>
    /// The two clauses that are selected for resolution.
    /// </summary>

    List<ProofTools.ResolveError> _errors = new();

    /// <summary>
    /// Indicates how many error messages are currently displayed
    /// </summary>
    int _toDeleteErrors; 

    /// <summary>
    /// Indicates whether the choice prompt window should be shown.
    /// </summary>
    bool _choicePrompt; 

    /// <summary>
    /// Indicates whether the rename prompt window should be shown
    /// </summary>
    bool _renamePrompt; 
    /// <summary>
    /// 
    /// </summary>
    int? _renameOriginal;


    private void StartLiteralSelector()
    {
        _choicePrompt = true;
        StateHasChanged();
    }

    // TBD.
    //private void ResolveEnd()
    //{
    //    Console.WriteLine($"ResolveEnd with {_resolveTarget} {_resolveSource}");
    //    if (_resolveSource == null || _resolveTarget == null)
    //    {
    //        Console.WriteLine($"Error {_resolveSource}");
    //        return;
    //    }
    //    if (_resolveSource != _resolveTarget)
    //    {
    //        var result = _proofTools.Resolve(
    //            (int) _resolveSource,
    //            (int) _resolveTarget,
    //            _resolutionFlow?.proof.GetClause((int)_resolveSource),
    //            _resolutionFlow?.proof.GetClause((int)_resolveTarget));
    //        if (result.IsLeft)
    //        {
    //            _resolutionFlow?.proof.Applications.Add(result.AsLeft);
    //        }
    //        if (result.IsMiddle)
    //        {
    //            _choicePrompt = true;
    //            _selection = new Tuple<int, int>((int)_resolveSource, (int)_resolveTarget);
    //            StateHasChanged();
    //            return;
    //        }
    //        if (result.IsRight)
    //        {
    //            _errors.Add(result.AsRight);

    //            Console.WriteLine($"Error list length: {_errors.Count} Index of new error {_errors.IndexOf(result.AsRight)} ");
    //        }
    //    }
    //    _resolveSource = null;
    //    _resolveTarget = null;
    //    StateHasChanged();
    //}

    // TBD
    //private void ResolveEndWithAtoms()
    //{
    //    Console.WriteLine($"ResolveEnd with {_resolveTarget} {_resolveSource} and {_proofTools.Print(_literals1)} {_proofTools.Print(_literals2)}");
    //    var result = _proofTools.Resolve(
    //        (int)_resolveSource,
    //        (int)_resolveTarget,
    //        _resolutionFlow?.proof.GetClause((int)_resolveSource),
    //        _resolutionFlow?.proof.GetClause((int)_resolveTarget),
    //        _literals1,
    //        _literals2);
    //    if (result.IsSuccesful)
    //    {
    //        _resolutionFlow?.proof.Applications.Add(result.Resolve);
    //    }
    //    else 
    //    {
    //        _errors.Add(result.Error);
    //        Console.WriteLine($"Error list length: {_errors.Count} Index of new error {_errors.IndexOf(result.Error)} ");
    //    }

    //    // Reset the proof step values to their original state, where nothing has been chosen yet.
    //    _resolveSource = null;
    //    _resolveTarget = null;
    //    _literals1 = new HashSet<Literal> {};
    //    _literals2 = new HashSet<Literal> {};
    //    _choicePrompt = false;
    //    StateHasChanged();
    //}


    /// <summary>
    /// Resolving function
    /// </summary>
    private void ResolveEnd(LiteralSelector selector)
    {
        Console.WriteLine($"ResolveEnd with {_resolveTarget} {_resolveSource}");
        var leftClause = _resolutionFlow?.proof.GetClause((int)_resolveSource);
        var rightClause = _resolutionFlow?.proof.GetClause((int)_resolveTarget);

        var result = _proofTools.Resolve(
            (int)_resolveSource,
            (int)_resolveTarget,
            leftClause,
            rightClause,
            selector.LeftSelectedLiterals,
            selector.RightSelectedLiterals
        );

        if (result.IsSuccesful)
        {
            _resolutionFlow?.proof.Applications.Add(result.Resolve);
        }
        else
        {
            _errors.Add(result.Error);
            Console.WriteLine($"Error list length: {_errors.Count} Index of new error {_errors.IndexOf(result.Error)} ");
        }

        ResetResolve();
    }

    private async void DeleteError()
    {
        _toDeleteErrors++;
        StateHasChanged();
        await Task.Delay(3000);
        _toDeleteErrors--;
        _errors.RemoveAt(0);
        StateHasChanged();
    }

    private void SetResolveSource(int index) 
    { 
        _resolveSource = index; 
        StateHasChanged(); 
    }

    private void SetResolveTarget(int index)
    {
        if (_resolveSource == null) return;
        _resolveTarget = index; 
        StateHasChanged();
    } 


    /// <summary>
    /// Resets the resolutions relevant stuff to zero.
    /// </summary>
    private void ResetResolve() 
    { 
        _resolveSource = 0; 
        _resolveTarget = 0; 
        _choicePrompt = false;
        StateHasChanged(); 
    }

    /// <summary>
    /// Delete a step from the proof.
    /// </summary>
    /// <param name="index"></param>
    private void Delete(int index) { _resolutionFlow.proof.DeleteApplication(index); StateHasChanged(); }

    /// <summary>
    /// Invoked to finish a renaming step. Calculates the new clause where the varaible is renamed to the target name. 
    /// Adds the renaming step to the proof.
    /// </summary>
    /// <param name="source"></param>
    /// <param name="target"></param>
    private void RenameEnd(string source, string target)
    {
        var clauseUsedForRenaming = _resolutionFlow.proof.GetClause((int)_renameOriginal);
        var rename = _proofTools.RenameVariable(source, target, (int)_renameOriginal, clauseUsedForRenaming);
        _resolutionFlow.proof.Applications.Add(rename);

        RenameStop();
    }

    /// <summary>
    /// Starts the process of renaming a variable. Opens the prompt.
    /// </summary>
    /// <param name="i"></param>
    private void RenameStart(int i)
    {
        _renameOriginal = i;
        _renamePrompt = true;
        StateHasChanged();
    }

    /// <summary>
    /// Cancel the renaming process of a variable. Close the prompt.
    /// </summary>
    private void RenameStop()
    {
        _renameOriginal = null;
        _renamePrompt = false;
        StateHasChanged();
    }

    /// <summary>
    /// DISABLED Summons the Isabelle proof generator to generate the formally verifiable proof, then copies to the clipboard.
    /// </summary>
    private void CopyProof()
    {
        // var c = new Isabelle.AST.ProofConnector(Isabelle.Compiler.compileProof(_resolutionFlow.proof));
        // ClipboardService.CopyToClipboard(Isabelle.Generator.generateSingle(c.x.Item1, c.x.Item2));
    }

}

